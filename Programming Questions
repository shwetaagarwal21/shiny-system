Program1 - 
1. Create a linked list with 3 nodes.
2. Traverse the created list and print the data of each node.
3. Insert a node -
	a. At the front of the linked list
	b. After a given node.
	c. At the end of the linked list.
4. Delete a node with given data
5. Delete a node at given position.
6. Find Length of a Linked List
	a. Iterative
	b. Recursive
7. Search an element in linked list
	a. Iterative
	b. Recursive
8. Swap nodes in a linked list without swapping data
9. Get Nth node in a linked list
10. Print the middle of a linked list. Given a singly linked list, find middle of the linked list. For example, if given linked list is 1->2->3->4->5 then output should be 3.
If there are even nodes, then there would be two middle nodes, we need to print second middle element. For example, if given linked list is 1->2->3->4->5->6 then output should be 4.
11. Find nth node from the end of a linked list.
12. Number of times a given data occurs in a linked list.
13. Reverse a linked list.
14. 

15. Detect a loop in linked list.
16. Find middle element of linked list in one pass.
17. How to find 3rd element from last in a Linked List in one Iteration or How to find nth element from last in a Linked List
18. Given a linked list which is sorted, how will you insert in sorted way.
19. Merge two sorted linked lists
20. Reverse every alternate k nodes of a linked list.
21. Quick Sort on doubly linked list


Nice to Review - 8, 13, 15, 16, 17, 18, 19, 
* Reverse a linked list
See before Interview - MergeSortedLists.java - merge sorted lists, using iterative and recursive



Trees - 
1. Pre-order traversal of Binary Tree
2. Post-order traversal of Binary Tree
3. In-order traversal of Binary Tree
4. Binary Tree Level Order Traversal
5. In-order Tree Traversal without recursion
6. Print all nodes of a binary tree that do not have sibling
7. Print all Root to Leaf paths of a Binary Tree
8. Minimum Depth of a Binary Tree
9. Find sum of all left leaves of a binary tree
10. The Great Tree-List Recursion Problem - Convert a Binary Tree to a Circular Doubly Link List


Graphs - 
1. DFS - 
2. BFS - use queue of linked list
3. Detect cycle in directed graph - use DFS, keep track of vertices currently in recursion stack for DFS traversal. 
If we reach a vertex that is already in the recursion stack, then there is a cycle in the tree.
4. Detect cycle in undirected graph - use DFS, For every visited vertex ‘v’, if there is an adjacent ‘u’ 
such that u is already visited and u is not parent of v, then there is a cycle in graph.
5. Topological Sorting -  for every directed edge uv, vertex u comes before v in the ordering. 
We need to print a vertex before its adjacent vertices. 
We use a temporary stack. We don’t print the vertex immediately, we first recursively call topological sorting for all its adjacent vertices, 
then push it to a stack. Finally, print contents of stack. 
Note that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on) are already in stack.
6. 


Remaining - 
Print right view of a binary tree
Print left view of a binary tree
Merge Sort for doubly linked list
Quick Sort for single linked list


Merge Sort for Single Linked List
Binary Tree to list 

OR symbol - ||

